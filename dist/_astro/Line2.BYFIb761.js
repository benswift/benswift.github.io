import{Mesh as q,Vector3 as w,InstancedInterleavedBuffer as G,InterleavedBufferAttribute as I,Sphere as N,Box3 as R,Vector4 as B,Line3 as F,Matrix4 as H,MathUtils as k}from"./three.module.d0yTp6cH.js";import{L as J,a as K}from"./LineGeometry.Wo7Yi1SC.js";import{LineMaterial as P}from"./LineMaterial.PpmBEBWK.js";const _=new B,j=new w,C=new w,i=new B,r=new B,x=new B,T=new w,W=new H,o=new F,D=new w,L=new R,z=new N,y=new B;let h,S;function E(c,t,n){return y.set(0,0,-t,1).applyMatrix4(c.projectionMatrix),y.multiplyScalar(1/y.w),y.x=S/n.width,y.y=S/n.height,y.applyMatrix4(c.projectionMatrixInverse),y.multiplyScalar(1/y.w),Math.abs(Math.max(y.x,y.y))}function Q(c,t){const n=c.matrixWorld,a=c.geometry,s=a.attributes.instanceStart,l=a.attributes.instanceEnd,u=Math.min(a.instanceCount,s.count);for(let e=0,p=u;e<p;e++){o.start.fromBufferAttribute(s,e),o.end.fromBufferAttribute(l,e),o.applyMatrix4(n);const f=new w,m=new w;h.distanceSqToSegment(o.start,o.end,m,f),m.distanceTo(f)<S*.5&&t.push({point:m,pointOnLine:f,distance:h.origin.distanceTo(m),object:c,face:null,faceIndex:e,uv:null,uv1:null})}}function X(c,t,n){const a=t.projectionMatrix,l=c.material.resolution,u=c.matrixWorld,e=c.geometry,p=e.attributes.instanceStart,f=e.attributes.instanceEnd,m=Math.min(e.instanceCount,p.count),d=-t.near;h.at(1,x),x.w=1,x.applyMatrix4(t.matrixWorldInverse),x.applyMatrix4(a),x.multiplyScalar(1/x.w),x.x*=l.x/2,x.y*=l.y/2,x.z=0,T.copy(x),W.multiplyMatrices(t.matrixWorldInverse,u);for(let M=0,O=m;M<O;M++){if(i.fromBufferAttribute(p,M),r.fromBufferAttribute(f,M),i.w=1,r.w=1,i.applyMatrix4(W),r.applyMatrix4(W),i.z>d&&r.z>d)continue;if(i.z>d){const b=i.z-r.z,g=(i.z-d)/b;i.lerp(r,g)}else if(r.z>d){const b=r.z-i.z,g=(r.z-d)/b;r.lerp(i,g)}i.applyMatrix4(a),r.applyMatrix4(a),i.multiplyScalar(1/i.w),r.multiplyScalar(1/r.w),i.x*=l.x/2,i.y*=l.y/2,r.x*=l.x/2,r.y*=l.y/2,o.start.copy(i),o.start.z=0,o.end.copy(r),o.end.z=0;const v=o.closestPointToPointParameter(T,!0);o.at(v,D);const A=k.lerp(i.z,r.z,v),U=A>=-1&&A<=1,V=T.distanceTo(D)<S*.5;if(U&&V){o.start.fromBufferAttribute(p,M),o.end.fromBufferAttribute(f,M),o.start.applyMatrix4(u),o.end.applyMatrix4(u);const b=new w,g=new w;h.distanceSqToSegment(o.start,o.end,g,b),n.push({point:g,pointOnLine:b,distance:h.origin.distanceTo(g),object:c,face:null,faceIndex:M,uv:null,uv1:null})}}}class Y extends q{constructor(t=new J,n=new P({color:Math.random()*16777215})){super(t,n),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,n=t.attributes.instanceStart,a=t.attributes.instanceEnd,s=new Float32Array(2*n.count);for(let u=0,e=0,p=n.count;u<p;u++,e+=2)j.fromBufferAttribute(n,u),C.fromBufferAttribute(a,u),s[e]=e===0?0:s[e-1],s[e+1]=s[e]+j.distanceTo(C);const l=new G(s,2,1);return t.setAttribute("instanceDistanceStart",new I(l,1,0)),t.setAttribute("instanceDistanceEnd",new I(l,1,1)),this}raycast(t,n){const a=this.material.worldUnits,s=t.camera;s===null&&!a&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const l=t.params.Line2!==void 0&&t.params.Line2.threshold||0;h=t.ray;const u=this.matrixWorld,e=this.geometry,p=this.material;S=p.linewidth+l,e.boundingSphere===null&&e.computeBoundingSphere(),z.copy(e.boundingSphere).applyMatrix4(u);let f;if(a)f=S*.5;else{const d=Math.max(s.near,z.distanceToPoint(h.origin));f=E(s,d,p.resolution)}if(z.radius+=f,h.intersectsSphere(z)===!1)return;e.boundingBox===null&&e.computeBoundingBox(),L.copy(e.boundingBox).applyMatrix4(u);let m;if(a)m=S*.5;else{const d=Math.max(s.near,L.distanceToPoint(h.origin));m=E(s,d,p.resolution)}L.expandByScalar(m),h.intersectsBox(L)!==!1&&(a?Q(this,n):X(this,s,n))}onBeforeRender(t){const n=this.material.uniforms;n&&n.resolution&&(t.getViewport(_),this.material.uniforms.resolution.value.set(_.z,_.w))}}class nt extends Y{constructor(t=new K,n=new P({color:Math.random()*16777215})){super(t,n),this.isLine2=!0,this.type="Line2"}}export{nt as Line2};
