import{InstancedBufferGeometry as f,Float32BufferAttribute as u,InstancedInterleavedBuffer as h,InterleavedBufferAttribute as o,WireframeGeometry as m,Box3 as c,Sphere as g,Vector3 as b}from"./three.module.d0yTp6cH.js";const a=new c,r=new b;class p extends f{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const t=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],s=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new u(t,3)),this.setAttribute("uv",new u(s,2))}applyMatrix4(t){const s=this.attributes.instanceStart,n=this.attributes.instanceEnd;return s!==void 0&&(s.applyMatrix4(t),n.applyMatrix4(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(t){let s;t instanceof Float32Array?s=t:Array.isArray(t)&&(s=new Float32Array(t));const n=new h(s,6,1);return this.setAttribute("instanceStart",new o(n,3,0)),this.setAttribute("instanceEnd",new o(n,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let s;t instanceof Float32Array?s=t:Array.isArray(t)&&(s=new Float32Array(t));const n=new h(s,6,1);return this.setAttribute("instanceColorStart",new o(n,3,0)),this.setAttribute("instanceColorEnd",new o(n,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new m(t.geometry)),this}fromLineSegments(t){const s=t.geometry;return this.setPositions(s.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new c);const t=this.attributes.instanceStart,s=this.attributes.instanceEnd;t!==void 0&&s!==void 0&&(this.boundingBox.setFromBufferAttribute(t),a.setFromBufferAttribute(s),this.boundingBox.union(a))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new g),this.boundingBox===null&&this.computeBoundingBox();const t=this.attributes.instanceStart,s=this.attributes.instanceEnd;if(t!==void 0&&s!==void 0){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let e=0;for(let i=0,l=t.count;i<l;i++)r.fromBufferAttribute(t,i),e=Math.max(e,n.distanceToSquared(r)),r.fromBufferAttribute(s,i),e=Math.max(e,n.distanceToSquared(r));this.boundingSphere.radius=Math.sqrt(e),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}class B extends p{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const s=t.length-3,n=new Float32Array(2*s);for(let e=0;e<s;e+=3)n[2*e]=t[e],n[2*e+1]=t[e+1],n[2*e+2]=t[e+2],n[2*e+3]=t[e+3],n[2*e+4]=t[e+4],n[2*e+5]=t[e+5];return super.setPositions(n),this}setColors(t){const s=t.length-3,n=new Float32Array(2*s);for(let e=0;e<s;e+=3)n[2*e]=t[e],n[2*e+1]=t[e+1],n[2*e+2]=t[e+2],n[2*e+3]=t[e+3],n[2*e+4]=t[e+4],n[2*e+5]=t[e+5];return super.setColors(n),this}setFromPoints(t){const s=t.length-1,n=new Float32Array(6*s);for(let e=0;e<s;e++)n[6*e]=t[e].x,n[6*e+1]=t[e].y,n[6*e+2]=t[e].z||0,n[6*e+3]=t[e+1].x,n[6*e+4]=t[e+1].y,n[6*e+5]=t[e+1].z||0;return super.setPositions(n),this}fromLine(t){const s=t.geometry;return this.setPositions(s.attributes.position.array),this}}const x=Object.freeze(Object.defineProperty({__proto__:null,LineGeometry:B},Symbol.toStringTag,{value:"Module"}));export{p as L,B as a,x as b};
