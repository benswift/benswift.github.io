<h2 id="description">Description</h2>

<p>We need to move this website from a static Jekyll site to a custom Elixir/Ash
(non-static) website. A sketch of the plan would be:</p>

<ul>
  <li>keep the blog posts and other “web content” md files as-is, and wrap them in a
custom Ash resource/action which used MDEx to convert them on the fly in
response to requests</li>
  <li>use phoenix liveview and presences to add cool dynamic features that aren’t
currently possible with a static website</li>
  <li>ditch pretty much all the sass/css from the current website; re-write a new
site using tailwind 4 and the new daisyUI components shipped with the new
Phoenix 1.18</li>
</ul>

<p>Post authoring would still be done by writing new md files in the git repo (this
does mean that creating/updating a post would require a full update and restart
of the app, but I’m fine with that in the short term). Aside from that, the new
Elixir app might not even need a data layer (e.g. sqlite, postgres). But that’s
a TBC that I will clarify through the design &amp; build process—it may be
necessary to add a proper data layer to add additional features in the future
(e.g. user accounts? not sure I want them, though).</p>

<p>Part of the migration approach would be to use the jekyll-sitemap plugin to
generate a sitemap.xml containing full paths to all pages on the current
(static) site, and then part of the testing for the new website would be to
iterate through every page and make sure that the new one responded with the
same content (modulo styling changes… in the short term, checking that it
least didn’t 404).</p>

<p>Additionally, google pagespeed insights and a11y would need to be part of the
tests as well—that stuff has been a priority for the jeykll site, and should
continue to be so going forward.</p>

<p>The current jekyll site has one particular custom plugin which reads a BibTeX
(<code>*.bib</code>) file and uses that information to populate a list of citations on e.g.
the main “Research” page. I would need to duplicate this in Ash/Elixir as well.</p>

<h3 id="libraries">Libraries</h3>

<ul>
  <li>latest Ash/Phoenix (must be 1.8 - rc is ok)/Phoenix LiveView (1.18)</li>
  <li>daisyUI for frontend components (as per Phoenix 1.8 defaults)</li>
  <li>use igniter wherever possible to install libraries</li>
  <li>MDEx for markdown parsing (with table and strikethrough extensions)</li>
  <li>bibtex_parser (https://hex.pm/packages/bibtex_parser) for BibTeX file parsing</li>
  <li>yaml_elixir for frontmatter parsing</li>
</ul>

<h2 id="detailed-implementation-plan">Detailed Implementation Plan</h2>

<h3 id="architecture-overview">Architecture Overview</h3>

<p>The new Elixir/Ash website will use a compile-time markdown processing approach
with Ash ManualRead actions to serve content without a traditional database. All
markdown files will be compiled to HTML at build time using MDEx, with the
compiled content stored in memory for fast access.</p>

<h3 id="1-content-processing-pipeline">1. Content Processing Pipeline</h3>

<h4 id="compile-time-markdown-processing">Compile-time Markdown Processing</h4>

<p>All markdown files will be processed at compile time using Elixir’s
<code>@external_resource</code> mechanism:</p>

<pre><code class="language-elixir"># lib/blog/content/compiler.ex
defmodule Blog.Content.Compiler do
  @posts_dir "priv/content/posts"
  @pages_dir "priv/content/pages"

  # Track all markdown files for recompilation
  for dir &lt;- [@posts_dir, @pages_dir] do
    @external_resource dir
  end

  # Process all content at compile time
  def compile_all do
    posts = compile_posts()
    pages = compile_pages()
    %{posts: posts, pages: pages}
  end

  defp compile_posts do
    Path.wildcard("#{@posts_dir}/**/*.md")
    |&gt; Enum.map(&amp;process_markdown_file/1)
    |&gt; Enum.filter(&amp;filter_by_environment/1)
    |&gt; Enum.sort_by(&amp; &amp;1.date, {:desc, Date})
  end

  defp process_markdown_file(path) do
    content = File.read!(path)
    {frontmatter, markdown} = parse_frontmatter(content)

    %{
      slug: extract_slug_from_path(path),
      title: frontmatter["title"],
      date: parse_date(frontmatter["date"]),
      tags: frontmatter["tags"] || [],
      draft: frontmatter["draft"] || false,
      frontmatter: frontmatter,
      raw_markdown: markdown,
      compiled_html: MDEx.to_html!(markdown, extension: [table: true, strikethrough: true]),
      excerpt: generate_excerpt(markdown),
      word_count: count_words(markdown),
      reading_time: calculate_reading_time(markdown),
      file_path: path
    }
  end

  defp filter_by_environment(%{draft: true}) do
    Application.get_env(:blog, :show_drafts, false)
  end
  defp filter_by_environment(_), do: true
end
</code></pre>

<h4 id="in-memory-storage">In-Memory Storage</h4>

<p>Content will be stored in module attributes for zero-latency access:</p>

<pre><code class="language-elixir"># lib/blog/content/store.ex
defmodule Blog.Content.Store do
  @moduledoc """
  In-memory store for all compiled content.
  Content is compiled at build time and stored as module attributes.
  """

  @content Blog.Content.Compiler.compile_all()
  @posts_by_slug @content.posts |&gt; Enum.map(&amp;{&amp;1.slug, &amp;1}) |&gt; Map.new()
  @posts_by_tag @content.posts |&gt; build_tag_index()

  def all_posts, do: @content.posts
  def all_pages, do: @content.pages

  def get_post(slug), do: Map.get(@posts_by_slug, slug)
  def posts_by_tag(tag), do: Map.get(@posts_by_tag, tag, [])

  def search_posts(query) do
    # Simple in-memory search - could be enhanced with better algorithms
    query_lower = String.downcase(query)

    Enum.filter(@content.posts, fn post -&gt;
      String.contains?(String.downcase(post.title), query_lower) or
      String.contains?(String.downcase(post.raw_markdown), query_lower) or
      Enum.any?(post.tags, &amp;String.contains?(String.downcase(&amp;1), query_lower))
    end)
  end

  defp build_tag_index(posts) do
    Enum.reduce(posts, %{}, fn post, acc -&gt;
      Enum.reduce(post.tags, acc, fn tag, tag_acc -&gt;
        Map.update(tag_acc, tag, [post], &amp;[post | &amp;1])
      end)
    end)
  end
end
</code></pre>

<h3 id="2-ash-resources-with-manual-actions">2. Ash Resources with Manual Actions</h3>

<h4 id="blog-post-resource">Blog Post Resource</h4>

<pre><code class="language-elixir"># lib/blog/resources/post.ex
defmodule Blog.Post do
  use Ash.Resource,
    domain: Blog,
    data_layer: Ash.DataLayer.Manual

  attributes do
    attribute :slug, :string, primary_key?: true, allow_nil?: false
    attribute :title, :string, allow_nil?: false
    attribute :date, :date, allow_nil?: false
    attribute :tags, {:array, :string}, default: []
    attribute :draft, :boolean, default: false
    attribute :frontmatter, :map
    attribute :raw_markdown, :string
    attribute :compiled_html, :string
    attribute :excerpt, :string
    attribute :word_count, :integer
    attribute :reading_time, :integer
    attribute :file_path, :string
  end

  actions do
    defaults [:read]

    read :by_slug do
      argument :slug, :string, allow_nil?: false
      manual Blog.Actions.Posts.BySlug
      get? true
    end

    read :by_tag do
      argument :tag, :string, allow_nil?: false
      manual Blog.Actions.Posts.ByTag
    end

    read :search do
      argument :query, :string, allow_nil?: false
      manual Blog.Actions.Posts.Search
    end

    read :recent do
      argument :limit, :integer, default: 10
      manual Blog.Actions.Posts.Recent
    end
  end

  code_interface do
    define :get_by_slug, args: [:slug], action: :by_slug
    define :list_by_tag, args: [:tag], action: :by_tag
    define :search, args: [:query]
    define :recent, args: [:limit]
  end
end
</code></pre>

<h4 id="manual-action-implementations">Manual Action Implementations</h4>

<pre><code class="language-elixir"># lib/blog/actions/posts/by_slug.ex
defmodule Blog.Actions.Posts.BySlug do
  use Ash.Resource.ManualRead

  def read(%{arguments: %{slug: slug}}, _opts, _context) do
    case Blog.Content.Store.get_post(slug) do
      nil -&gt; {:error, Ash.Error.Query.NotFound.exception(resource: Blog.Post)}
      post -&gt; {:ok, [struct(Blog.Post, post)]}
    end
  end
end

# lib/blog/actions/posts/search.ex
defmodule Blog.Actions.Posts.Search do
  use Ash.Resource.ManualRead

  def read(%{arguments: %{query: query}} = ash_query, _opts, _context) do
    results =
      Blog.Content.Store.search_posts(query)
      |&gt; Enum.map(&amp;maybe_highlight_excerpt(&amp;1, query))
      |&gt; Enum.map(&amp;struct(Blog.Post, &amp;1))
      |&gt; paginate(ash_query)

    {:ok, results}
  end

  defp maybe_highlight_excerpt(post, query) do
    # For search results, dynamically generate highlighted excerpts
    if should_highlight?(post, query) do
      highlighted_excerpt =
        post.raw_markdown
        |&gt; extract_context_around_match(query)
        |&gt; highlight_matches(query)
        |&gt; MDEx.to_html!()

      %{post | excerpt: highlighted_excerpt}
    else
      post
    end
  end
end
</code></pre>

<h3 id="3-phoenix-integration">3. Phoenix Integration</h3>

<h4 id="liveview-controllers">LiveView Controllers</h4>

<pre><code class="language-elixir"># lib/blog_web/live/post_live/show.ex
defmodule BlogWeb.PostLive.Show do
  use BlogWeb, :live_view

  @impl true
  def mount(%{"slug" =&gt; slug}, _session, socket) do
    case Blog.Post.get_by_slug(slug) do
      {:ok, post} -&gt;
        {:ok,
         socket
         |&gt; assign(:post, post)
         |&gt; assign(:page_title, post.title)
         |&gt; assign(:meta_tags, build_meta_tags(post))}

      {:error, _} -&gt;
        {:ok,
         socket
         |&gt; put_flash(:error, "Post not found")
         |&gt; redirect(to: ~p"/posts")}
    end
  end

  @impl true
  def render(assigns) do
    ~H"""
    &lt;article class="prose prose-lg mx-auto"&gt;
      &lt;header&gt;
        &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
        &lt;div class="text-base-content/60"&gt;
          &lt;time datetime={@post.date}&gt;&lt;%= format_date(@post.date) %&gt;&lt;/time&gt;
          · &lt;%= @post.reading_time %&gt; min read
        &lt;/div&gt;
      &lt;/header&gt;

      &lt;div class="mt-8"&gt;
        &lt;%= raw(@post.compiled_html) %&gt;
      &lt;/div&gt;

      &lt;footer class="mt-8"&gt;
        &lt;div class="flex gap-2"&gt;
          &lt;.link :for={tag &lt;- @post.tags}
                 navigate={~p"/posts/tag/#{tag}"}
                 class="badge badge-primary"&gt;
            &lt;%= tag %&gt;
          &lt;/.link&gt;
        &lt;/div&gt;
      &lt;/footer&gt;
    &lt;/article&gt;
    """
  end
end
</code></pre>

<h3 id="4-bibtex-integration">4. BibTeX Integration</h3>

<p>Using the <code>bibtex_parser</code> package for robust BibTeX parsing:</p>

<pre><code class="language-elixir"># mix.exs dependencies
{:bibtex_parser, "~&gt; 0.1.0"}

# lib/blog/bibliography/store.ex
defmodule Blog.Bibliography.Store do
  @bib_file "priv/content/bibliography.bib"
  @external_resource @bib_file

  # Parse BibTeX at compile time using bibtex_parser
  @entries @bib_file
           |&gt; File.read!()
           |&gt; BibtexParser.parse()
           |&gt; process_entries()

  def all_entries, do: @entries
  def get_entry(key), do: Enum.find(@entries, &amp;(&amp;1.key == key))

  def entries_by_year do
    @entries
    |&gt; Enum.group_by(&amp; &amp;1.year)
    |&gt; Enum.sort_by(&amp;elem(&amp;1, 0), :desc)
  end

  def entries_by_type(type) do
    Enum.filter(@entries, &amp;(&amp;1.type == type))
  end

  defp process_entries({:ok, entries}) do
    Enum.map(entries, &amp;transform_entry/1)
  end
  defp process_entries({:error, _reason}), do: []

  defp transform_entry(entry) do
    %{
      key: entry.key,
      type: entry.type,
      title: clean_latex(entry.fields["title"]),
      author: format_authors(entry.fields["author"]),
      year: entry.fields["year"],
      url: entry.fields["url"],
      doi: entry.fields["doi"],
      journal: entry.fields["journal"],
      booktitle: entry.fields["booktitle"],
      raw: entry
    }
  end

  defp clean_latex(text) when is_binary(text) do
    text
    |&gt; String.replace(~r/\{|\}/, "")
    |&gt; String.replace(~r/\\"/, "")
  end
  defp clean_latex(nil), do: nil

  defp format_authors(authors) when is_binary(authors) do
    authors
    |&gt; String.split(" and ")
    |&gt; Enum.map(&amp;String.trim/1)
  end
  defp format_authors(nil), do: []
end

# lib/blog_web/components/citation_helpers.ex
defmodule BlogWeb.CitationHelpers do
  use Phoenix.Component

  def citation_list(assigns) do
    ~H"""
    &lt;div class="space-y-4"&gt;
      &lt;article :for={entry &lt;- @entries} class="citation"&gt;
        &lt;div class="font-medium"&gt;
          &lt;%= entry.title %&gt;
        &lt;/div&gt;
        &lt;div class="text-sm text-base-content/70"&gt;
          &lt;%= Enum.join(entry.author, ", ") %&gt; · &lt;%= entry.year %&gt;
        &lt;/div&gt;
        &lt;div :if={entry.journal} class="text-sm italic"&gt;
          &lt;%= entry.journal %&gt;
        &lt;/div&gt;
        &lt;div :if={entry.url} class="text-sm"&gt;
          &lt;.link href={entry.url} target="_blank" class="link link-primary"&gt;
            &lt;%= if entry.doi, do: "DOI: #{entry.doi}", else: "Link" %&gt;
          &lt;/.link&gt;
        &lt;/div&gt;
      &lt;/article&gt;
    &lt;/div&gt;
    """
  end
end
</code></pre>

<h3 id="5-development--deployment-considerations">5. Development &amp; Deployment Considerations</h3>

<h4 id="environment-configuration">Environment Configuration</h4>

<pre><code class="language-elixir"># config/dev.exs
config :blog,
  show_drafts: true,
  content_dirs: ["priv/content", "test/fixtures/content"]

# config/runtime.exs
config :blog,
  show_drafts: System.get_env("SHOW_DRAFTS", "false") == "true"
</code></pre>

<h4 id="deployment-process">Deployment Process</h4>

<ol>
  <li><strong>Build Step</strong>: All markdown files are compiled during <code>mix compile</code></li>
  <li><strong>Release</strong>: Content is embedded in the release binary</li>
  <li><strong>Updates</strong>: New content requires redeployment (automated via CI/CD)</li>
  <li><strong>No Hot Reload</strong>: Content changes require restart in production</li>
</ol>

<h4 id="testing-strategy">Testing Strategy</h4>

<pre><code class="language-elixir"># test/blog/migration_test.exs
defmodule Blog.MigrationTest do
  use ExUnit.Case

  @jekyll_sitemap "test/fixtures/jekyll-sitemap.xml"

  test "all Jekyll URLs return 200 or proper redirects" do
    sitemap_urls = parse_sitemap(@jekyll_sitemap)

    for url &lt;- sitemap_urls do
      conn = get(build_conn(), url)
      assert conn.status in [200, 301]
    end
  end

  test "pagespeed scores meet threshold" do
    # Run Lighthouse CI tests
    assert pagespeed_score(:performance) &gt;= 95
    assert pagespeed_score(:accessibility) &gt;= 100
    assert pagespeed_score(:seo) &gt;= 100
  end
end
</code></pre>

<h3 id="6-future-enhancements">6. Future Enhancements</h3>

<p>While not part of the initial implementation, the architecture supports:</p>

<ol>
  <li><strong>Analytics</strong>: Add view counting using ETS counters</li>
  <li><strong>Comments</strong>: Could add LiveView-powered comments without a database</li>
  <li><strong>Admin Interface</strong>: LiveView admin for content preview (dev only)</li>
  <li><strong>RSS/Atom</strong>: Generate feeds at compile time</li>
  <li><strong>Search Enhancement</strong>: Add full-text search with pre-built indices</li>
</ol>

<h3 id="notes">Notes</h3>

<ul>
  <li>This approach trades deployment flexibility for performance and simplicity</li>
  <li>All content is immutable once deployed, ensuring consistency</li>
  <li>Memory usage scales linearly with content amount (not a concern per
requirements)</li>
  <li>SEO and performance should match or exceed Jekyll due to pre-compilation</li>
</ul>

<h3 id="7-implementation-checklist">7. Implementation Checklist</h3>

<h4 id="initial-phoenix-setup">Initial Phoenix Setup</h4>

<pre><code class="language-bash"># Create new Phoenix app with no database
mix phx.new blog --no-ecto --live
cd blog

# Add dependencies to mix.exs
{:ash, "~&gt; 3.0"},
{:mdex, "~&gt; 0.1"},
{:yaml_elixir, "~&gt; 2.9"},
{:bibtex_parser, "~&gt; 0.1.0"}

# Install with igniter where possible
mix igniter.install ash
</code></pre>

<h4 id="directory-structure">Directory Structure</h4>

<pre><code>priv/
  content/
    posts/
      2024/
        01-15-my-first-post.md
        02-20-another-post.md
    pages/
      about.md
      research.md
    bibliography.bib
  static/
    images/
    downloads/
    robots.txt
</code></pre>

<h4 id="markdown-frontmatter-format">Markdown Frontmatter Format</h4>

<pre><code class="language-yaml">---
title: "My Blog Post Title"
date: 2024-01-15
tags: [elixir, phoenix, web]
draft: false  # Optional, defaults to false
excerpt: "Optional custom excerpt"
---

Post content here...
</code></pre>

<h4 id="helper-functions-to-implement">Helper Functions to Implement</h4>

<pre><code class="language-elixir"># lib/blog/content/frontmatter.ex
defmodule Blog.Content.Frontmatter do
  def parse(file_content) do
    case String.split(file_content, ~r/^---$/m, parts: 3) do
      ["", frontmatter, content] -&gt;
        {:ok, YamlElixir.read_from_string!(frontmatter), String.trim(content)}
      _ -&gt;
        {:ok, %{}, file_content}
    end
  end
end

# lib/blog/content/helpers.ex
defmodule Blog.Content.Helpers do
  def extract_slug_from_path(path) do
    path
    |&gt; Path.basename(".md")
    |&gt; String.replace(~r/^\d{4}-\d{2}-\d{2}-/, "")
  end

  def generate_excerpt(markdown, length \\ 160) do
    markdown
    |&gt; String.replace(~r/^#.*$/m, "")
    |&gt; String.replace(~r/\[([^\]]+)\]\([^\)]+\)/, "\\1")
    |&gt; String.replace(~r/[*_`]/, "")
    |&gt; String.trim()
    |&gt; String.slice(0, length)
    |&gt; Kernel.&lt;&gt;("...")
  end

  def count_words(text) do
    text
    |&gt; String.split(~r/\s+/)
    |&gt; length()
  end

  def calculate_reading_time(text, wpm \\ 200) do
    ceil(count_words(text) / wpm)
  end
end
</code></pre>

<h4 id="route-configuration">Route Configuration</h4>

<pre><code class="language-elixir"># lib/blog_web/router.ex
scope "/", BlogWeb do
  pipe_through :browser

  live "/", HomeLive.Index, :index
  live "/posts", PostLive.Index, :index
  live "/posts/:slug", PostLive.Show, :show
  live "/posts/tag/:tag", PostLive.Index, :tag
  live "/search", SearchLive.Index, :index
  live "/:page", PageLive.Show, :show  # For static pages like /about
end
</code></pre>

<h4 id="phoenix-18-specific-setup">Phoenix 1.8 Specific Setup</h4>

<pre><code class="language-elixir"># assets/tailwind.config.js
module.exports = {
  content: [
    "./js/**/*.js",
    "../lib/*_web.ex",
    "../lib/*_web/**/*.*ex"
  ],
  theme: {
    extend: {},
  },
  plugins: [
    require("@tailwindcss/typography"),  // For prose styling
    require("daisyui")
  ],
  daisyui: {
    themes: ["light", "dark"],  // Enable theme switching
  },
}
</code></pre>

<h4 id="seo-meta-tags">SEO Meta Tags</h4>

<pre><code class="language-elixir"># lib/blog_web/components/layouts/root.html.heex
&lt;head&gt;
  &lt;meta charset="utf-8" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
  &lt;meta name="csrf-token" content={get_csrf_token()} /&gt;
  
  &lt;%= if assigns[:meta_tags] do %&gt;
    &lt;meta name="description" content={@meta_tags.description} /&gt;
    &lt;meta property="og:title" content={@meta_tags.title} /&gt;
    &lt;meta property="og:description" content={@meta_tags.description} /&gt;
    &lt;meta property="og:type" content={@meta_tags.type || "website"} /&gt;
    &lt;meta name="twitter:card" content="summary" /&gt;
  &lt;% end %&gt;
  
  &lt;.live_title suffix=" · Ben Swift"&gt;
    &lt;%= assigns[:page_title] || "Ben Swift" %&gt;
  &lt;/.live_title&gt;
  
  &lt;link phx-track-static rel="stylesheet" href={~p"/assets/app.css"} /&gt;
  &lt;script defer phx-track-static type="text/javascript" src={~p"/assets/app.js"}&gt;
  &lt;/script&gt;
&lt;/head&gt;
</code></pre>
